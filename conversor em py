# -*- coding: utf-8 -*-
import os
import re
import shutil
from decimal import Decimal, ROUND_HALF_UP
import pdfplumber

def frac_to_decimal(s):
    s = s.strip()
    if "/" in s:
        parts = s.split()
        if len(parts) == 2:
            whole, frac = parts
        else:
            whole, frac = "0", parts[0]
        num, den = frac.split("/")
        return Decimal(whole) + Decimal(num) / Decimal(den)
    return Decimal(s.replace(",", ".").replace(" ", ""))

def inches_to_mm_str(raw):
    m = re.search(r'([\d\.,/ ]+)(?=(?:\"|MM))', raw, re.IGNORECASE)
    if not m:
        return "SEM_DIM"
    token = m.group(1).strip()
    try:
        inches = frac_to_decimal(token)
        mm = (inches * Decimal("25.4")).quantize(Decimal("0.1"),
                                                  rounding=ROUND_HALF_UP)
        return str(mm).replace(".", ",")
    except Exception:
        return "SEM_DIM"

def extrair_texto(path_pdf):
    with pdfplumber.open(path_pdf) as pdf:
        return "\n".join(page.extract_text() or "" for page in pdf.pages)

def extrair_data(texto):
    m = re.search(r"Emiss(?:ã|a)o:\s*(\d{2})/(\d{2})/(\d{4})",
                  texto, re.IGNORECASE)
    if not m:
        return "SEM_DATA"
    dia, mes, ano = m.groups()
    return f"{dia}_{mes}_{ano}"

def parse_desc_lines(texto):
    lines = [l.strip() for l in texto.splitlines() if l.strip()]
    # captura linhas que comecem com número e contenham material (INOX, I 304/316, EPDM, BORRACHA)
    pad = re.compile(
        r'^\d+\s+.*?(?:INOX|I\s*\d{3,4}L?|EPDM|BORRACHA)',
        re.IGNORECASE
    )
    return [l for l in lines if pad.match(l)]


def limpar_descricao(desc_line):
    tokens = desc_line.split()

    # remove primeiro token (número sequencial do item, ex: "1")
    tokens = tokens[1:]

    # ignora códigos puramente numéricos ou com pontos/barras
    desc_tokens = []
    for t in tokens:
        if re.match(r'^[\d\./]+$', t):  # só número/ponto/barra → ignora
            continue
        desc_tokens.append(t)

    texto = " ".join(desc_tokens)

    # corta na primeira aspa se houver (para evitar lixo depois)
    texto = re.split(r'(?<=\d)(?=\")', texto)[0].replace("/", "_")

    # substitui múltiplos espaços
    texto = re.sub(r'\s+', " ", texto).strip()
    return texto

def extrair_material(desc_line):
    m = re.search(r'(?:INOX|I)\s+(\d{3,4}L?)', desc_line, re.IGNORECASE)
    if m:
        return m.group(1).upper()
    if re.search(r'EPDM', desc_line, re.IGNORECASE):
        return "EPDM"
    if re.search(r'BORRACHA', desc_line, re.IGNORECASE):
        return "BORRACHA"
    return "SEM_MAT"

def sanitize_filename(name):
    # remove caracteres inválidos no Windows
    return re.sub(r'[\\/*?:"<>|]', "_", name)

def processa_arquivos(arquivos, output_dir, log_widget):
    os.makedirs(output_dir, exist_ok=True)

    for src in arquivos:
        fname = os.path.basename(src)
        try:
            texto = extrair_texto(src)
            data  = extrair_data(texto)
            descs = parse_desc_lines(texto)
            subp  = os.path.splitext(fname)[0]
            pasta_item = os.path.join(output_dir, subp)
            os.makedirs(pasta_item, exist_ok=True)

            for linha in descs:
                descricao = limpar_descricao(linha)
                material  = extrair_material(linha)
                dim_mm    = inches_to_mm_str(linha)
                novo_nome = f"{descricao} - {material} - {dim_mm}mm - {data}.pdf"
                novo_nome = sanitize_filename(novo_nome)

                dst = os.path.join(pasta_item, novo_nome)

                base, ext = os.path.splitext(dst)
                cnt = 1
                while os.path.exists(dst):
                    dst = f"{base}_{cnt}{ext}"
                    cnt += 1

                shutil.copy(src, dst)
                log_widget.insert("end", f"Gerado: {dst}\n")

        except Exception as e:
            log_widget.insert("end", f"[ERRO] {fname}: {e}\n")
