# -*- coding: utf-8 -*-
import os
import re
import shutil
from decimal import Decimal, ROUND_HALF_UP
import pdfplumber

def frac_to_decimal(s):
    s = s.strip()
    if "/" in s:
        parts = s.split()
        if len(parts) == 2:
            whole, frac = parts
        else:
            whole, frac = "0", parts[0]
        num, den = frac.split("/")
        return Decimal(whole) + Decimal(num) / Decimal(den)
    return Decimal(s.replace(",", ".").replace(" ", ""))

def inches_to_mm_str(raw):
    matches = re.findall(r'([\d\.,/]+)(?=(?:\"|MM))', raw, re.IGNORECASE)
    if not matches:
        return "SEM_DIM"

    token = matches[-1].strip()
    token = re.sub(r'(\d+)\.(\d+)/(\d+)', r'\1 \2/\3', token)  # corrige 1.1/2

    try:
        inches = frac_to_decimal(token)
        mm = (inches * Decimal("25.4")).quantize(Decimal("0.1"),
                                                  rounding=ROUND_HALF_UP)
        return str(mm).replace(".", ",")
    except Exception:
        return "SEM_DIM"

def extrair_texto(path_pdf):
    with pdfplumber.open(path_pdf) as pdf:
        return "\n".join(page.extract_text() or "" for page in pdf.pages)

def extrair_data(texto):
    m = re.search(r"Emiss(?:ã|a)o:\s*(\d{2})/(\d{2})/(\d{4})",
                  texto, re.IGNORECASE)
    if not m:
        return "SEM_DATA"
    dia, mes, ano = m.groups()
    return f"{dia}_{mes}_{ano}"

def parse_desc_lines(texto):
    lines = [l.strip() for l in texto.splitlines() if l.strip()]
    pad = re.compile(
        r'^\d+\s+.*?(?:INOX|I\s*\d{3,4}L?|EPDM|BORRACHA)',
        re.IGNORECASE
    )
    return [l for l in lines if pad.match(l)]

def limpar_descricao(desc_line):
    tokens = desc_line.split()
    tokens = tokens[1:]  # remove número do item

    desc_tokens = []
    for t in tokens:
        if re.match(r'^[\d\./]+$', t):
            continue
        desc_tokens.append(t)

    texto = " ".join(desc_tokens)
    texto = re.split(r'(?<=\d)(?=\")', texto)[0].replace("/", "_")
    return re.sub(r'\s+', " ", texto).strip()

def extrair_material(desc_line):
    m = re.search(r'(?:INOX|I)\s+(\d{3,4}L?)', desc_line, re.IGNORECASE)
    if m:
        return m.group(1).upper()
    if re.search(r'EPDM', desc_line, re.IGNORECASE):
        return "EPDM"
    if re.search(r'BORRACHA', desc_line, re.IGNORECASE):
        return "BORRACHA"
    return "SEM_MAT"

def sanitize_filename(name):
    return re.sub(r'[\\/*?:"<>|]', "_", name)

def processa_arquivos(arquivos, output_dir, log_widget, progress=None):
    os.makedirs(output_dir, exist_ok=True)

    for src in arquivos:
        fname = os.path.basename(src)
        try:
            texto = extrair_texto(src)
            data  = extrair_data(texto)
            descs = parse_desc_lines(texto)

            pasta_item = output_dir  # não cria subpasta extra

            for linha in descs:
                descricao = limpar_descricao(linha)
                material  = extrair_material(linha)
                dim_mm    = inches_to_mm_str(linha)
                novo_nome = f"{descricao} - {material} - {dim_mm}mm - {data}.pdf"
                novo_nome = sanitize_filename(novo_nome)

                dst = os.path.join(pasta_item, novo_nome)

                base, ext = os.path.splitext(dst)
                cnt = 1
                while os.path.exists(dst):
                    dst = f"{base}_{cnt}{ext}"
                    cnt += 1

                shutil.copy(src, dst)

                # escreve log
                log_widget.insert("end", f"Gerado: {dst}\n")
                log_widget.see("end")

                # atualiza progressbar (se fornecida)
                if progress:
                    progress["value"] += 1
                    progress.update_idletasks()

        except Exception as e:
            log_widget.insert("end", f"[ERRO] {fname}: {e}\n")
            log_widget.see("end")
